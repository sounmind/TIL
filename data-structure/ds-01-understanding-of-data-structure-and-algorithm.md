- C언어의 문법과 관련해 알고 있다고 가정하는 부분
    1. 구조체를 정의할 줄 알고 구조체 대상의 typedef 선언을 할 줄 안다.
    2. malloc 함수와 free 함수를 사용할 줄 알고, 이는 메모리 동적 할당과 관련 있음을 이해한다.
    3. 포인터 변수의 선언과 포인터 연산에 부담이 없다.
    4. 헤더파일이 필요한 이유를 이해한다.
    5. 헤더파일을 정의할 줄 알고 헤더파일에 나누어 담을 줄 안다.
    6. 재귀함수의 동작방식을 안다. 그리고 재귀함수와 관련된 아주 간단한 예제는 분석할 수 있다.

# 1.1. 자료구조에 대한 기본적인 이해

---

## 자료구조란 무엇인가?

자료구조는 데이터를 표현하고 저장하는 방법에 대한 것이다.

> 프로그램이란 데이터를 표현하고, 그렇게 표현된 데이터를 처리하는 것이다.

위의 '데이터의 표현'은 '데이터의 저장' 개념을 포함하고 있다. 이 '데이터의 저장'을 담당하는 것이 바료 자료구조이다.

## 자료구조의 분류

- 선형구조
    - 리스트
    - 스택
    - 큐
- 비선형구조
    - 트리
    - 그래프

- 파일구조
    - 순차파일
    - 색인파일
    - 직접파일
- 단순구조
    - 정수
    - 실수
    - 문자
    - 문자열

## 본서의 자료구조 학습 방향

실무에서는 자료구조를 직접 구현 않고 검증된 라이브러리를 가져다 쓴다. 이는 안정성에서나 성능 면에서나 합리적인 선택이다. 하지만 라이브러리를 잘 가져다 쓰려면 자료구조를 잘 알기도 하거니와 그 각각의 특성을 정확히 이해해야 한다.

하지만 실무에서 정보를 저장하기 위한 자료구조를 선택할 때, 자료구조의 구현 능력은 그리 중요하지 않을 수 있다. 하지만 코드 레벨에서 자료구조를 구현한 경험이 있다면 자료구조를 더 잘 알게 된다. 자료구조를 보는 깊이가 달라진다고 할 수 있다.

## 자료구조와 알고리즘의 관계

자료구조가 '데이터의 표현 및 저장방법'을 뜻한다면, 알고리즘은 이렇듯 표현 및 저장된 데이터를 대상으로 하는 '문제의 해결 방법'을 뜻한다. 예를 들어, '배열의 선언'은 자료구조적 측면의 코드이고, '배열에 저장된 모든 값을 더하는 반복문'은 알고리즘적 측면의 코드이다.

자료구조와 알고리즘은 밀접한 관계를 갖는다. 자료구조가 결정되어야 그에 따른 효율적인 알고리즘을 결정할 수 있기 때문이다. 즉, 자료구조에 따라 알고리즘은 달라진다. 알고리즘은 자료구조에 의존적이다.

# 1.2. 알고리즘 성능분석 방법

## 시간 복잡도와 공간 복잡도

우리가 선택할 자료구조와 알고리즘이 잘 동작하는 것은 물론이거니와 좋은 성능까지 보장받기를 원하기 때문에, 우리는 자료구조와 알고리즘을 분석하고 평가할 수 있어야 한다. 

알고리즘을 평가하는 두 가지 요소는 다음과 같이 정리할 수 있다.

> 어떤 알고리즘이 어떠한 상황에서 더 빠르고 또 느리냐?

> 어떤 알고리즘이 어떠한 상황에서 메모리를 적게 쓰고 또 많이 쓰냐?

- 하나는 **'속도'**에 관한 것이고 다른 하나는 **'메모리의 사용량'**에 관한 것인데, 속도에 해당하는 알고리즘의 수행시간 분석결과를 가리켜 **'시간 복잡도'**라 하고, 메모리 사용량에 대한 분석결과를 가리켜 **'공간 복잡도'**라 한다.
- 이진 탐색 알고리즘을 구현해보자!

    ```c
    #include <stdio.h>

    int BSearch(int array[], int len, int target)
    {
        int first = 0;      // 탐색 대상의 시작 인덱스 값
        int last = len - 1; // 탐색 대상의 마지막 인덱스 값
        int mid;

        while (first <= last) // 배열의 처음이 마지막 보다 작거나 같을 때
        {
            mid = (first + last) / 2; // 탐색 대상의 중앙을 찾는다
            if (target == array[mid]) // 중앙에 저장된 것이 타겟이라면
            {
                return mid; // 탐색 완료!
            }
            else // 타겟이 아니라면 탐색 대상을 반으로 줄이기
            {
                if (target < array[mid])
                    last = mid - 1; // 왜 -1을 하였을까? -> 타겟이 중앙값보다 작기 때문에 탐색하려는 배열의 마지막을 중앙값의 이전 값으로 변경
                else
                    first = mid + 1; // 왜 +1을 하였을까? -> 타겟이 중앙값보다 크기 때문에 탐색하려는 배열의 처음을 중앙값 오른쪽으로 다시 설정
            }
        }
        return -1; // 찾지 못했을 때 반환되는 값
    }

    int main(void)
    {
        int arr[] = {1, 3, 5, 7, 9};
        int idx;

        idx = BSearch(arr, sizeof(arr) / sizeof(int), 7);
        if (idx == -1)
            printf("탐색 실패\n");
        else
            printf("타겟 저장 인덱스: %d \n", idx);

        idx = BSearch(arr, sizeof(arr) / sizeof(int), 4);
        if (idx == -1)
            printf("탐색 실패\n");
        else
            printf("타겟 저장 인덱스: %d \n", idx);

        return 0;
    }
    ```

# 2. 재귀

- 이진탐색을 재귀함수로!

    ```c
    #include <stdio.h>

    int BSearchRecur(int ar[], int first, int last, int target)
    {
        int mid;
        if (first > last) // -1의 반환은 탐색의 실패를 의미
            return -1;    // 탐색 대상의 중앙을 찾는다
        mid = (first + last) / 2;

        if (ar[mid] == target)
            return mid; // 탐색된 타겟의 인덱스 값 반환
        else if (target < ar[mid])
            return BSearchRecur(ar, first, mid - 1, target);
        else
            return BSearchRecur(ar, mid + 1, last, target);
    }

    int main(void)
    {
        int arr[] = {1, 3, 5, 7, 9};
        int idx;

        idx = BSearchRecur(arr, 0, sizeof(arr) / sizeof(int) - 1, 7);
        if (idx == -1)
            printf("탐색 실패 \n");
        else
            printf("타겟 저장 인덱스: %d \n", idx);

        idx = BSearchRecur(arr, 0, sizeof(arr) / sizeof(int) - 1, 4);
        if (idx == -1)
            printf("탐색 실패 \n");
        else
            printf("타겟 저장 인덱스: %d \n", idx);

        return 0;
    }
    ```