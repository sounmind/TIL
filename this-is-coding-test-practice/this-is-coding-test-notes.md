[(이코테 2021 강의 몰아보기) 1. 코딩 테스트 출제 경향 분석 및 파이썬 문법 부수기](https://www.youtube.com/watch?v=m-9pAwq1o3w&list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC)

- 코딩 테스트 출제 경향 분석 및 파이썬 문법 부수기

    # 코딩테스트 개요 및 출제경향

    # 알고리즘 성능 평가

    ## 복잡도

    - 복잡도의 종류
        - 시간 복잡도
        - 공간 복잡도
    - 복잡도의 표기법
        - 빅오 표기법
            - 가장 빠르게 증가하는 항만을 고려하는 표기법. 함수의 상한만을 나타내게 된다.
    - 시간 복잡도 계산해보기
        - 모든 이중 반복문의 시간복잡도가 O(N^2)인 것은 아니다. 소스코드가 내부적으로 다른 함수를 호출한다면, 그 함수의 시간 복잡도까지 고려해야 한다.

    ## 알고리즘 설계 Tip

    - 일반적으로 CPU 기반의 개인 컴퓨터나 채점용 컴퓨터에서 연산 횟수가 5억을 넘어가는 경우:
        - C언어 기준 통상 1~3초, Python은 5~15초 가량의 시간이 소요된다.
            - PyPy의 경우 때때로 C언어보다도 빠르게 동작하기도 한다. 그러니 시간이 초과됐을 경우 PyPy로도 제출해보는 것도 좋을 수 있다.
    - 코딩 테스트 문제에서 시간제한은 통상 1~5초 가량이라는 점에 유의. 혹여 문제에 명시되어 있지 않은 경우 대략 5초라고 생각하고 문제를 푸는 것이 합리적.

    ### 요구사항에 따라 적절한 알고리즘 설계하기

    - 문제에서 가장 먼저 확인해야 하는 내용은 시간제한(수행시간 요구사항)이다.
    - 시간제한이 1초인 문제에서 일반적인 기준은 다음과 같다.
        1. N의 범위가 500인 경우: 시간복잡도가 O(N^3)인 알고리즘 설계 시 문제를 풀 수 있다.
        2. N의 범위가 2000인 경우: 시간복잡도가 O(N^2)인 알고리즘 설계 시 문제를 풀 수 있다.
        3. N의 범위가 100000인 경우: 시간복잡도가 O(NlogN)인 알고리즘 설계 시 문제를 풀 수 있다.
        4. N의 범위가 10000000인 경우: 시간복잡도가 O(N)인 알고리즘 설계 시 문제를 풀 수 있다.

    ## 일반적인 알고리즘 문제 해결 과정

    > 나는 이 문제를 간결하고 창의적으로 풀 수 있다고 스스로 확신을 갖고 문제 풀이를 시작하기

    1. 지문 읽기 및 컴퓨터적 사고
    2. 요구사항(복잡도) 분석
    3. 문제 해결을 위한 아이디어 찾기
    4. 소스코드 설계 및 코딩

    > 일반적으로 대부분의 문제 출제자들은 핵심 아이디어를 알아낸다면 간결하게 소스코드를 작성할 수 있는 형태로 문제를 출제한다.

    ## 수행 시간 측정 소스코드 예제

    ```python
    import time
    start_time = time.time()  # 측정 시작
    # ...
    # 소스 코드
    # ...
    end_time = time.time() # 측정 종료
    print("time: ", end_time - start_time) # 수행 시간 출력
    ```

    # 파이썬 문법

    ## 파이썬 | 자료형

    ### 정수형

    ### 실수형

    - 소수부가 0일 때 0을 생략하거나 정수부가 0일때 0을 생략할 수 있다.
    - 지수표현방식 (기본적으로 실수형)
        - 파이썬에서는 e나 E를 이용한 지수표현방식을 이용할 수 있다.
        - e나 E 다음에 오는 수는 10의 지수부를 의미한다. (`1e9` → 10의 9제곱)
        - 지수 표현 방식은 임의의 큰 수를 표현하기 위해 자주 사용된다.
        - **최단 경로 알고리즘에서는 도달할 수 없는 노드에 대하여 최단 거리를 무한(`INF`)로 설정하곤 한다.**
        - 이때 가능한 최댓값이 10억 미만이라면 무한(`INF`)의 값으로 `1e9`를 이용할 수 있다.
    - 오늘날 가장 널리 쓰이는 IEEE754 표준에서는 실수형을 저장하기 위해 4바이트, 또는 8바이트의 고정된 크기의 메모리를 할당하므로, 컴퓨터 시스템은 실수 정보를 표현하는 정확도에 한계를 가진다.
        - 예를 들어 10진수 체계에서 0.3 + 0.6 = 0.9로 정확히 떨어진다. 하지만 2진수에서는 0.9를 정확히 표현할 수 있는 방법이 없다. 컴퓨터는 최대한 0.9와 가깝게 표현하지만, 미세한 오차가 발생하게 된다.
        - 권장되는 해결 방법 → `round()` 반올림
    - 수 자료형의 연산
        - 수 자료형에서 사칙연산과 나머지 연산자가 많이 사용된다.
        - 하지만 나누기 연산자(/)는 주의해서 사용해야 한다.
            - 파이썬에서 나누기 연산자(/)는 나눠진 결과를 실수형으로 반환한다.
        - 다양한 로직을 설계할 때 나머지 연산자(%)를 이용해야 할 때가 많다.
        - 파이썬에서는 몫을 얻기 위해 몫 연산자(//)를 사용한다.
        - 이외에도 거듭 제곱 연산자(**)를 비롯해 다양한 연산자들이 존재한다.

    ### 리스트 자료형

    - 여러 개의 데이터를 연속적으로 담아 처리하기 위해 사용하는 자료형
        - 사용자 입장에서 C나 Java에서의 배열(Array)의 기능 및 연결 리스트와 유사한 기능을 지원한다.
        - 리스트 대신에 배열 혹은 테이블이라고 부르기도 한다.
        - 모든 값이 0인 1차원 리스트 초기화

            ```python
            n=10
            a=[0]*n # [0,0,0,0,0,0,0,0,0,0]
            ```

    - 리스트의 인덱싱과 슬라이싱
        - 리스트에서 연속적인 위치를 갖는 원소들을 가져와야 할 때는 슬라이싱을 이용한다.
            - 대괄호 안에 콜론(:)을 넣어서 시작 인덱스와 끝 인덱스를 설정할 수 있다.
            - 끝 인덱스는 실제 인덱스보다 1을 더 크게 설정한다.
    - 리스트 컴프리헨션
        - 리스트를 초기화하는 방법 중 하나.
            - 대괄호 안에 **조건문**과 **반복문**을 적용하여 리스트를 초기화할 수 있다.

                ```python
                array = [i for i in range(5)] # [0, 1, 2, 3, 4]
                array = [i for i in range(10) if i % 2 == 1] # [1, 3, 5, 7, 9]
                array = [i * i for i in range(1, 10)] # 1부터 9까지 수들의 제곱 값을 포함하는 리스트
                ```

        - 리스트 컴프리헨션은 2차원 리스트를 초기화할 때 효과적으로 사용될 수 있다.
        - 특히 N * M 크기의 2차원 리스트를 한 번에 초기화 할 때 유용하다.
            - **좋은 예시: array = [[0] * m for _ in range(n)]**
        - 만약 2차원 리스트를 초기화할 때 다음과 같이 작성하면 예기치 않은 결과가 나올 수 있다.
            - 잘못된 예시: array = [[0] * m] * n

                위 코드는 전체 리스트 안에 포함된 각 리스트가 모두 같은 객체로 인식된다.

    - 언더바는 언제 사용하는가?
        - 파이썬에서는 반복을 수행하되 반복을 위한 변수의 값을 무시하고자 할 때 언더바(_)를 자주 사용한다.
    - 리스트 관련 기타 메서드

    - 리스트에서 특정 값을 가지는 원소를 모두 제거하기

        ```python
        a = [1,2,3,4,5,5,5]
        remove_set = {3, 5} # 집합 자료형 (집합 자료형은 추후에 다룸)

        # remove_list에 포함되지 않은 값만을 저장
        result = [i for i in a if i not in remove_set]
        print(result) # [1, 2, 4]
        ```

    ### 문자열 자료형

    - 문자열 변수를 초기화할 때는 큰따옴표나 작은따옴표를 이용한다.
    - 문자열 안에 큰따옴표나 작은따옴표가 포함되어야 하는 경우가 있다.
        - 전체 문자열을 큰(작은)따옴표를 구성하는 경우, 내부적으로 작은(큰)따옴표를 포함할 수 있다.
        - 혹은 백슬래시(\)를 사용하면, 큰따옴표나 작은따옴표를 원하는 만큼 포함시킬 수 있다.
    - 문자열 연산
        - 문자열 변수에 덧셈을 이용하면 문자열이 더해져 연결된다.
        - 문자열 변수를 특정한 양의 정수와 곱하는 경우, 문자열이 그 값만큼 여러 번 더해진다.
        - 문자열도 리스트와 마찬가지로 인덱싱과 슬라이싱을 이용할 수 있다. 하지만 문자열은 특정 인덱스의 값을 변경할 수 없다(Immutable).

    ### 튜플 자료형

    - 튜플 자료형은 리스트와 유사하지만 다음과 같은 문법적 차이가 있다.
        - 튜플은 한 번 선언된 값을 변경할 수 없다.
        - 리스트는 대괄호([])를 이용하지만, 튜플은 소괄호(())를 이용한다.
    - 튜플은 리스트에 비해 상대적으로 공간 효율적이다.
    - 튜플을 사용하면 좋은 경우
        - 서로 다른 성질의 데이터를 묶어서 관리해야 할 때, **최단 경로 알고리즘에서는 (비용, 노드 번호)의 형태**로 튜플 자료형을 자주 사용한다.
        - 데이터의 나열을 **해싱(Hashing)의 키 값**으로 사용해야 할 때, 튜플은 변경이 불가능하므로 리스트와 다르게 키 값으로 사용될 수 있다.
        - 리스트보다 **메모리를 효율적**으로 사용해야 할 때

    ### 사전 자료형

    - 사전 자료형은 키(Key)와 값(Value)의 쌍을 데이터로 가지는 자료형이다. 원하는 '변경 불가능한 자료형'을 키로 사용할 수 있다.
    - 파이썬의 사전 자료형은 해시 테이블(Hash Table)을 이용하므로 데이터의 조회 및 수정에 있어서 O(1)의 시간에 처리할 수 있다.
    - 사전 자료형 관련 메서드
        - 사전 자료형에서는 키와 값을 별도로 뽑아내기 위한 메서드를 지원한다.
            - 키 데이터만 뽑아서 리스트로 이용할 때는 `keys()` 함수를 이용
            - 값 데이터만 뽑아서 리스트로 이용할 때는 `values()` 함수를 이용

    ### 집합 자료형

    - 집합의 특징
        - 중복을 허용하지 않는다.
        - 순서가 없다.
    - 집합은 리스트 혹은 문자열을 이용해서 초기화할 수 있다. 이때 `set()` 함수를 이용한다.
    - 혹은 중괄호({})안에 각 원소를 콤파(,)를 기준으로 구분하여 삽입함으로써 초기화 할 수 있다.
    - 데이터의 조회 및 수정에 있어서 O(1)의 시간에 처리할 수 있다.
    - 집합 자료형의 연산
        - 기본적인 집합 연산으로 합집합(`a ㅣ b`), 교집합(`a & b`), 차집합(`a - b`) 연산이 있다.
    - 집합 자료형 관련 함수
        - `add()`, `update()`, `remove()`
    - 사전 자료형과 집합 자료형의 특징
        - 리스트나 튜플은 순서가 있기 때문에 인덱싱을 통해 자료형의 값을 얻을 수 있다.
        - 사전 자료형과 집합 자료형은 순서가 없기 때문에 인덱싱으로 값을 없을 수 없다. 사전의 키 혹은 집합의 원소를 이용해 O(1)의 시간복잡도로 조회한다.
        - 

    ## 파이썬 | 기본 입출력

    ### 자주 사용되는 표준 입력 방법

    - input() 함수는 한 줄의 문자열을 입력 받음.
    - map() 함수는 리스트의 모든 원소에 각각 특정한 함수를 적용할 때 사용.
        - 예시1) 공백을 기준으로 구분된 데이터를 입력 받을 때는 다음과 같이 사용한다.
            - `list(map(int, input().split()))`
                - `input().split()` → 입력된 문자열이 공백으로 구분된 리스트가 된다.
        - 예시2) 공백을 기준으로 구분된 데이터의 개수가 많지 않다면, 단순히 다음과 같이 사용한다.
            - `a, b, c = map(int, input().split())`

    ### 빠르게 입력 받기

    - 사용자로부터 입력을 최대한 빠르게 받아야 하는 경우가 있다.
        - 파이썬의 경우 sys 라이브러리에 정의되어 있는 `sys.stdin.readline()` 메서드를 이용한다. 단, 입력 후 엔터(Enter)가 줄바꿈 기호로 입력되므로 `rstrip()` 메서드를 함께 사용한다.

            ```python
            import sys
            # 문자열 빠르게 입력 받기
            data = sys.stdin.readline().rstrip()
            ```

    ### 자주 사용되는 표준 출력 방법

    - 파이썬에서 기본 출력은 print() 함수를 이용한다. 각 변수를 콤마(,)를 이용하여 띄어쓰기로 구분하여 출력할 수 있다.
    - print()는 기본적으로 출력 이후에 줄 바꿈을 수행한다. 줄 바꿈을 원치 않는 경우 'end' 속성을 이용할 수 있다.
    - f-string 예제
        - 파이썬 3.6부터 사용 가능하며, 문자열 앞에 접두사 'f'를 붙여 사용한다.
        - 중괄호 안에 변수명을 기입하여 간단히 문자열과 정수를 함께 넣을 수 있다.

    ## 파이썬 | 조건문

    ---

    - 조건문은 프로그램의 흐름을 제어하는 문법. 조건문을 이용해 조건에 따라서 프로그램의 로직을 설정할 수 있다.

    ### 파이썬의 기타 연산자

    - 다수의 데이터를 담는 자료형을 위해 `in` 연산자와 `not in` 연산자가 제공된다. **리스트, 튜플, 문자열, 딕셔너리** 모두에서 사용이 가능하다.

    ### 조건문의 간소화

    - 조건문에서 실행될 소스코드가 한 줄인 경우, 굳이 줄 바꿈을 하지 않고도 간략하게 표현할 수 있다.

        ```python
        score = 85
        if score >= 80: result = "Success"
        else: result = "Fail"
        ```

    - 조건부 표현식(Conditional Expression)은 if ~ else 문을 한 줄에 작성할 수 있도록 해준다.

        ```python
        score = 85
        result = "Success" if score >= 80 else "Fail"
        ```

    ### 파이썬 조건문 내에서의 부등식

    - 다른 프로그래밍 언어와 다르게 파이썬은 조건문 안에서 수학의 부등식을 그대로 사용할 수 있다.


    ## 반복문

    ---

    - 특정한 소스코드를 반복적으로 실행하고자 할 때 사용하는 문법입니다.
    - 파이썬에서는 while문과 for문이 있는데, 어떤 것을 사용해도 상관 없습니다.
        - 다만 코딩 테스트에서의 실제 사용 예시를 확인해 보면, for문이 더 간결한 경우가 많습니다.

    ### 반복문: for문

    - for문에서 연속적인 값을 차례대로 순회할 때는 `range()`를 주로 사용한다. 이때 `range(시작 값, 끝 값+1)` 형태로 사용한다. 인자를 하나만 넣으면 자동으로 시작 값은 0이 된다.

    ### 파이썬의 continue 키워드

    - 반복문에서 남은 코드의 실행을 건너뛰고, 다음 반복을 진행하고자 할 때 continue를 사용한다.

    ### 파이썬의 break 키워드

    - 반복문을 즉시 탈출하고자 할 때 break를 사용한다.

    ## 파이썬 | 함수와 람다 표현식

    ---

    ### 함수

    - 함수란 특정한 작업을 하나의 단위로 묶어 놓은 것을 의미한다. 함수를 사용하면 불필요한 소스코드의 반복을 줄일 수 있다.
    - 함수의 종류
        - 내장 함수
        - 사용자 정의 함수
    - 함수 정의하기
        - 매개변수(parament): 함수 내부에서 사용할 변수
            - 파라미터의 변수를 직접 지정할 수 있다. 이 경우 매개변수의 순서가 달라도 상관이 없다.
        - 반환 값: 함수에서 처리 된 결과를 반환
        - 인자(argument): 코드에서 함수의 매개변수 자리에 넣는 값
        - global 키워드
            - global 키워드로 변수를 지정하면 해당 함수에서는 지역 변수를 만들지 않고, 함수 바깥에 선언된 변수를 바로 참조하게 됩니다.
        - 여러 개의 반환 값
            - 파이썬에서 함수는 여러 개의 반환 값을 가질 수 있다.
            - 팩킹(여러 개를 반환 값으로 전달하는 것)과 언팩킹(여러 개의 반환 값을 변수에 대입하는 것)

    ### 람다 표현식

    - 람다 표현식을 이용하면 함수를 간단하게 작성할 수 있다. 특정한 기능을 수행하는 함수를 한 줄에 작성할 수 있다는 점이 특징이다.

    ```python
    def add(a, b):
    	return a + b
    # 일반적인 add() 메서드 사용
    print(add(3, 7))

    # 람다 표현식으로 구현한 add() 메서드
    print((lambda a, b: a + b)(3, 7))
    ```

    - 람다 표현식 예시: 내장 함수에서 자주 사용되는 람다 함수

        > 매개변수에 어떻게 대입이 되는 것인지 잘 모르겠다...

    ## 실전에서 유용한 표준 라이브러리

    ---

    - 내장 함수: 기본 입출력 함수부터 정렬 함수까지 기본적인 함수들을 제공한다. 파이썬 프로그램을 작성할 때 없어서는 안 되는 필수적인 기능을 포함하고 있다.

    - itertools: 파이썬에서 반복되는 형태의 데이터를 처리하기 위한 유용한 기능들을 제공한다. 특히 **순열과 조합** 라이브러리는 코딩 테스트에서 자주 사용된다. **중복순열과 중복조합**도 있다!

    - heapq: 힙(Heap) 자료구조를 제공한다. 일반적으로 우선순위 큐 기능을 구현하기 위해 사용된다.
    - bisect: 이진 탐색(Binary Search) 기능을 제공한다.
    - collections: 덱(deque), 카운터(Counter) 등의 유용한 자료구조를 포함한다.

    - math: 필수적인 수학적 기능을 제공한다. 팩토리얼, 제곱근, 최대공약수(GCD), 삼각함수 관련 함수부터 파이(pi)와 같은 상수를 포함한다.


- 그리디 & 구현

    # 그리디 알고리즘

    - 그리디 알고리즘(탐욕법)은 현재 상황에서 지금 당장 좋은 것만 고르는 방법을 의미한다.
    - 일반적인 그리디 알고리즘은 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구한다.
    - 그리디 해법은 그 정당성 분석이 중요하다
        - 단순히 가장 좋아보이는 것을 반복적으로 선택해도 최적의 해를 구할 수 있는 검토해야 한다.
    - 일반적인 상황에서 그리디 알고리즘은 최적의 해를 보장할 수 없을 때가 많다.
    - 대부분의 코딩테스트 그리디 문제는 탐욕법으로 얻은 해가 최적의 해가 되는 상황에서, 이를 추론할 수 있어야 풀리도록 출제된다.
    - 문제1 | 거스름 돈
        - 당신은 음식점의 계산을 도와주는 점원이다. 카운터에는 거스름돈으로 사용할 500원, 100원, 50원, 10원짜리 동전이 무한히 존재한다고 가정한다. 손님에게 거슬러 주어야 할 돈이 N원일 때 거슬러 주어야 할 동전의 최소 개수를 구하시오. 단, 거슬러 줘야 할 돈 N은 항상 10의 배수이다.
        - 정당성 분석
            - 가장 큰 화폐 단위부터 돈을 거슬러 주는 것이 최적의 해를 보장하는 이유는?
                - **가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문이다.**

                그리디 알고리즘 문제에서는 이처럼 문제 풀이를 위한 최소한의 아이디어를 떠올리고 이것이 정당한지 검토할 수 있어야 한다.

        - 시간복잡도 분석
            - 화폐의 종류만큼 반복이 수행되므로 시간 복잡도는 O(N)이다.

    # 구현

    - 구현이란, 머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정이다.
    - 흔히 알고리즘 대회에서 구현 유형의 문제란 무엇을 의미할까?
        - 풀이를 떠올리는 것은 쉽지만 소스코드로 옮기기 어려운 문제를 지칭한다.
        - 예시
            1. 알고리즘은 간단한데 코드가 지나칠 만큼 길어지는 문제
            2. 실수 연산을 다루고, 특정 소수점 자리까지 출력해야 하는 문제
            3. 문자열을 특정한 기준에 따라서 끊어 처리해야 하는 문제
            4. 적절한 라이브러리를 찾아서 사용해야 하는 문제
    - 일반적으로 알고리즘 문제에서의 2차원 공간은 **행렬**(Matrix)의 의미로 사용된다.
    - 시뮬레이션 및 완전 탐색 문제에서는 2차원 공간에서의 **방향 벡터**가 자주 활용된다.

- DFS / BFS
    # 그래프 탐색 알고리즘: DFS

    ---

    - 탐색이란 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정을 말한다
    - 대표적 그래프 탐색 알고리즘으로는 DF BFS가 있다.
    - DFS/BFS는 코딩테스트에서 매우 자주 등장하는 유형이므로 반드시 숙지해야 한다.

    ## 스택 자료구조

    - 먼저 들어온 데이터가 나중에 나가는 형식의 자료구조
    - 입구와 출구가 동일한 형태로 스택을 시각화할 수 있다
    - 갑자기 뜬 금 없 이 알게 된 파이썬 리스트 거꾸로 출력 **[방법](https://itholic.github.io/python-reverse-string/) → 꼭 익히자!**

    ## 큐 자료구조

    - 먼저 들어 온 데이터가 먼저 나가는 형식의 자료구조입니다.
    - 큐는 입구와 출구가 모두 뚫려 있는 터널과 같은 형태로 시각화 할 수 있다.
    - 큐를 구현할 때 꼭 deque를 import해서 사용하자!

    ## 재귀 함수

    - 자기 자신을 다시 호출하는 함수
    - 재귀 함수를 문제 풀이에서 사용할 때는 재귀 함수의 종료 조건을 반드시 명시해야 한다. 종료 조건을 제대로 명시하지 않으면 함수가 무한히 호출 될 수 있다.

    ```jsx
    def gcd(a, b):
        if a % b == 0:
                    return b
            else:
                    return gcd(b, a % b)
    ```

    - 컴퓨터가 함수를 연속적으로 호출하면 컴퓨터 메모리 내부의 스택 프레임에 쌓인다. **그래서 스택을 사용해야 할 때 구현상 스택 라이브러리 대신에 재귀 함수를 이용하는 경우가 많다.**

    ## DFS

    - 깊이 우선 탐색, 깊은 부분을 우선적으로 탐색하는 알고리즘
    - 스택 자료구조(혹은 재귀 함수)를 이용한다.
    - 동작 과정 **→ 무슨 말인지 모르겠다!!!**
        1. 탐색 시작 노드를 스택에 삽입하고 방문 처리를 한다.
        2. 스택의 최상단 노드에 방문하지 않은 인접한 노드가 하나라도 있으면 그 노드를 스택에 넣고 방문 처리한다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다.
        3. 더 이상 2번의 과정을 수행할 수 없을 때까지 반복한다.

    ## BFS
    - 너비 우선 탐색, 가까운 노드부터 우선적으로 탐색하는 알고리즘
    - 큐 자료구조를 이용한다.
    - 동작 과정
        1. 탐색 시작 노드를 큐에 삽입하고 방문 처리를 한다.
        2. 큐에서 노드를 꺼낸 뒤에 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리한다.
        3. 더 이상 2번의 과정을 수행할 수 없을 때까지 반복한다.
    - **거리 당 비용이 동일한 최단 거리 문제에 활용될 수 있다.**

# 정렬 알고리즘
- 정렬이란 데이터를 특정한 기준에 따라 순서대로 나열하는 것을 말한다.
- 일반적으로 문제 상황에 따라 적절한 정렬 알고리즘이 공식처럼 사용된다.

## 선택 정렬

```python
# 선택 정렬 교재 예시

array = [7, 5, 9, 0, 1, 6, 2, 4, 8]
# i번째 요소를 그 이후 요소의 최솟값과 교체한다.
for i in range(len(array)):
    min_index = i  # 가장 작은 원소의 인덱스
    for j in range(i + 1, len(array)):  # 나머지 요소 중 최솟값 찾기
        if array[min_index] > array[j]:
            min_index = j
    array[i], array[min_index] = array[min_index], array[i]  # 값 서로 바꾸기
    print(array)

# 실행결과
# [0, 5, 9, 7, 1, 6, 2, 4, 8]
# [0, 1, 9, 7, 5, 6, 2, 4, 8]
# [0, 1, 2, 7, 5, 6, 9, 4, 8]
# [0, 1, 2, 4, 5, 6, 9, 7, 8]
# [0, 1, 2, 4, 5, 6, 9, 7, 8]
# [0, 1, 2, 4, 5, 6, 9, 7, 8]
# [0, 1, 2, 4, 5, 6, 7, 9, 8]
# [0, 1, 2, 4, 5, 6, 7, 8, 9]
# [0, 1, 2, 4, 5, 6, 7, 8, 9]
```

- 선택 정렬은 N번 만큼 가장 작은 수를 찾아서 맨 앞으로 보내야 한다.
- 구현 방식에 따라 사소한 오차는 있을 수 있지만, 전체  연산 횟수는 다음과 같다.

    > N + (N-1) + (N-2) + ... + 2

- 이는 $(N^2+N-2)/2$로 표현할 수 있는데, 빅오 표기법에 따라 $O(N^2)$이라고 작성한다.

## 삽입 정렬

- 처리되지 않은 데이터를 하나씩 골라 적절한 위치에 삽입한다.
- 선택 정렬에 비해 구현 난이도가 높은 편이지만, 일반적으로 더 효율적으로 동작한다.

```python
# 삽입 정렬
array = [7, 5, 9, 0, 1, 6, 2, 4, 8]

# i번째 요소를 그 이전의 모든 요소와 비교하여 작으면 교체하고, 크면 그대로 둔다.
for i in range(1, len(array)):
    for j in range(i, 0, -1):  # 인덱스 i부터 1까지 1씩 감소
        if array[j] < array[j - 1]:  # j번째 요소가 그 이전 요소보다 작다면
            array[j], array[j - 1] = array[j - 1], array[j]  # 서로 교체
            print(i, array)
        else:  # 작지 않다면 그대로 두고 다음 요소로 넘어감
            break

# 출력 결과 (교체될 때만)
# 1 [5, 7, 9, 0, 1, 6, 2, 4, 8]
# 3 [5, 7, 0, 9, 1, 6, 2, 4, 8]
# 3 [5, 0, 7, 9, 1, 6, 2, 4, 8]
# 3 [0, 5, 7, 9, 1, 6, 2, 4, 8]
# 4 [0, 5, 7, 1, 9, 6, 2, 4, 8]
# 4 [0, 5, 1, 7, 9, 6, 2, 4, 8]
# 4 [0, 1, 5, 7, 9, 6, 2, 4, 8]
# 5 [0, 1, 5, 7, 6, 9, 2, 4, 8]
# 5 [0, 1, 5, 6, 7, 9, 2, 4, 8]
# 6 [0, 1, 5, 6, 7, 2, 9, 4, 8]
# 6 [0, 1, 5, 6, 2, 7, 9, 4, 8]
# 6 [0, 1, 5, 2, 6, 7, 9, 4, 8]
# 6 [0, 1, 2, 5, 6, 7, 9, 4, 8]
# 7 [0, 1, 2, 5, 6, 7, 4, 9, 8]
# 7 [0, 1, 2, 5, 6, 4, 7, 9, 8]
# 7 [0, 1, 2, 5, 4, 6, 7, 9, 8]
# 7 [0, 1, 2, 4, 5, 6, 7, 9, 8]
# 8 [0, 1, 2, 4, 5, 6, 7, 8, 9]
```

- 삽입 정렬의 시간 복잡도는 $O(N^2)$이며, 선택 정렬과 마찬가지로 반복문이 두 번 중첩되어 사용된다.
- 삽입 정렬은 현재 리스트의 데이터가 **거의 정렬되어 있는 상태**라면 매우 빠르게 동작한다.
    - 최선의 경우, O(N)의 시간 복잡도를 가진다.
    - 이미 정렬되어 있는 상태에서 다시 삽입 정렬을 수행하면? → 반복문을 한 번만 사용하게 됨.

## 퀵 정렬

- 기준 데이터를 설정하고 그 **기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방법**
- 일반적인 가장 많이 사용되는 정렬 알고리즘 중 하나.
- 병합 정렬과 더불어 대부분의 프로그래밍 언어의 정렬 라이브러리의 근간이 되는 알고리즘
- 가장 기본적인 퀵 정렬은 **첫 번째 데이터를 기준 데이터(Pivot)**로 설정한다.
- 동작 예시
    - 왼쪽에서부터 기준 데이터(첫 번째 데이터)보다 큰 값, 오른쪽에서부터 기준 데이터보다 작은 값을 골라 위치를 바꾼다.
    - 반복한다.
    - **위치가 엇갈리는 경우 '피벗(기준 데이터)'과 '작은 데이터'의 위치를 서로 변경한다. 이것을 분할이라고 한다.**

        ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cd01af6f-1d04-439a-a60c-5c90b8248e12/Untitled.png](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/cd01af6f-1d04-439a-a60c-5c90b8248e12/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20201116%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20201116T170122Z&X-Amz-Expires=86400&X-Amz-Signature=a067db4014634ac9e0722b90016f24f39dc3cca816deffeca55d0829c58ad4d3&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22)

    - **분할이 완료되면, 피벗의 왼쪽에 있는 데이터는 모두 피벗보다 작고, 오른쪽에 있는 데이터는 모두 피벗보다 크다.**

        ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0bf05f07-9d91-4b7c-89a2-367d6a5bc4fe/Untitled.png](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/0bf05f07-9d91-4b7c-89a2-367d6a5bc4fe/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20201116%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20201116T170108Z&X-Amz-Expires=86400&X-Amz-Signature=f67013eddacd335b443abef31dd04baa9906786691400a61a7bdec1847197ba1&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22)

    - 피벗 왼쪽에 있는 배열, 오른쪽에 있는 배열에 모두 퀵 정렬을 수행한다.

    ### 퀵 정렬이 빠른 이유

    ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1cb5e2d8-988c-4cd4-82a3-2f5816e003ff/Untitled.png](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/1cb5e2d8-988c-4cd4-82a3-2f5816e003ff/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20201116%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20201116T170045Z&X-Amz-Expires=86400&X-Amz-Signature=afeb86338c0d92c7a2860384a671b2d2157ef3cb1d0c2f8946d650224b3dcee1&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22)

    - 퀵 정렬은 평균의 경우 $O(NlogN)$의 시간 복잡도를 가진다.
    - 하지만 최악의 경우 $O(N^2)$의 시간 복잡도를 가진다.
        - 이미 정렬된 배열에 퀵 정렬을 수행할 때와 같다.

    ```python
    # 퀵 정렬
    array = [7, 5, 9, 0, 1, 6, 2, 4, 8]

    def quick_sort(array, start, end):
        if start >= end:  # 원소가 1개인 경우 종료
            return
        pivot = start  # 피벗(기준 데이터)은 첫 번째 원소

        # 탐색을 시작하는 (피벗 다음) 왼쪽 끝 원소,
        # 탐색이 끝나면 피벗보다 큰 데이터의 인덱스를 저장된다.
        left = start + 1

        # 탐색이 끝나면 피벗보다 작은 데이터의 인덱스가 저장된다.
        right = end
        while left <= right:  # 왼쪽 끝 원소가 오른쪽 끝 원소보다 작거나 같을 때 반복
            # 피벗보다 큰 데이터를 찾을 때까지 반복
            while left <= end and array[left] <= array[pivot]:
                left += 1
            # 피벗보다 작은 데이터를 찾을 때까지 반복
            while right > start and array[right] >= array[pivot]:
                right -= 1
            if left > right:  # 엇갈렸다면 작은 데이터와 피벗을 교체
                array[right], array[pivot] = array[pivot], array[right]
                print("분할!", end=" ")
            else:  # 엇갈리지 않았다면 작은 데이터와 큰 데이터를 교체
                array[left], array[right] = array[right], array[left]
            print(array)
        # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행
        quick_sort(array, start, right - 1)
        quick_sort(array, right + 1, end)

    quick_sort(array, 0, len(array) - 1)

    # 출력 결과
    # [7, 5, 4, 0, 1, 6, 2, 9, 8]
    # 분할! [2, 5, 4, 0, 1, 6, 7, 9, 8]
    # [2, 1, 4, 0, 5, 6, 7, 9, 8]
    # [2, 1, 0, 4, 5, 6, 7, 9, 8]
    # 분할! [0, 1, 2, 4, 5, 6, 7, 9, 8]
    # 분할! [0, 1, 2, 4, 5, 6, 7, 9, 8]
    # 분할! [0, 1, 2, 4, 5, 6, 7, 9, 8]
    # 분할! [0, 1, 2, 4, 5, 6, 7, 9, 8]
    # 분할! [0, 1, 2, 4, 5, 6, 7, 8, 9]
    ```

    ### 파이썬의 장점을 살려 간결하게 작성한 퀵 정렬 소스코드

    ```python
    # 파이썬의 장점을 살려 간결하게 작성한 퀵 정렬 소스코드
    array = [7, 5, 9, 0, 1, 6, 2, 4, 8]

    def quick_sort(array):
        # 리스트의 원소가 하나 이하라면 종료
        if len(array) <= 1:
            return array
        pivot = array[0]  # 피벗은 첫 번째 원소
        tail = array[1:]  # 피벗을 제외한 리스트

        # 피벗보다 작은 요소만 담긴 리스트 (피벗을 포함)
        left_side = [x for x in tail if x <= pivot]
        # 피벗보다 큰 요소만 담긴 리스트
        right_side = [x for x in tail if x > pivot]
        # 분할 완료

        # 분할 이후 왼쪽과 오른쪽 리스트에 각각 퀵정렬 수행하고, 전체 리스트 반환
        return quick_sort(left_side) + [pivot] + quick_sort(right_side)

    print(quick_sort(array))
    ```

## 계수 정렬

- **특정한 조건이 부합**할 때만 사용할 수 있지만 **매우 빠르게** 동작하는 정렬 알고리즘입니다.
    - 계수 정렬은 **데이터의 크기 범위가 제한되어 정수 형태로 표현**할 수 있을 때 사용 가능합니다.
- 데이터의 개수가 $N$, 데이터(양수) 중 최댓값이 $K$일 때 최악의 경우에도 수행 시간 $O(N+K)$를 보장한다.

### 계수 정렬 동작 예시

1. 가장 작은 데이터부터 가장 큰 데이터까지의 범위가 모두 담길 수 있도록 리스트를 생성한다.
2. 데이터를 하나씩 확인하며 데이터의 값과 동일한 인덱스의 값을 1씩 증가시킨다.
3. 최종 리스트의 첫 번째 데이터부터 하나씩 그 값만큼 반복하여 인덱스를 출력한다.

```python
# 계수 정렬
# 모든 원소의 값이 0보다 크거나 같다고 가정
array = [7, 5, 6, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2]
# 모든 범위를 포함하는 리스트 선언(모든 값은 0으로 초기화)
count = [0] * (max(array) + 1)

for i in range(len(array)):
    count[array[i]] += 1  # 각 데이터에 해당하는 인덱스의 값 증가시키기

for i in range(len(count)):  # 리스트에 기록된 정렬 정보 확인
    for j in range(count[i]):
        print(i, end=" ")
```

### 계수 정렬의 복잡도 분석

- 계수 정렬의 시간 복잡도와 공간 복잡도는 모두 $O(N+K)$이다.
- 계수 정렬은 때에 따라서 심각한 비효율성을 초래할 수 있다.
    - 예시 → 데이터가 0과 999,999,999로 단 2개만 존재하는 경우
- 계수 정렬은 동일한 값을 가지는 데이터가 여러 개 등장할 때 효과적으로 사용할 수 있다.
    - 성적의 경우 100점을 맞은 학생이 여러 명일 수 있기 때문에 계수 정렬이 효과적입니다.

## 정렬 알고리즘 비교하기

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b52b866d-57a9-49bf-9d7c-65f135c9cc1d/Untitled.png](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/b52b866d-57a9-49bf-9d7c-65f135c9cc1d/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20201117%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20201117T162556Z&X-Amz-Expires=86400&X-Amz-Signature=7b66542f37ee5b4d6c64649ad04da974b001594756e3e7d8ec52a1f501622fb3&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22)

## 연습 문제

- 풀이

    ```python
    N, K = map(int, input().split(" "))
    A = list(map(int, input().split(" "))).sort()
    B = list(map(int, input().split(" "))).sort(reverse=True)

    for i in range(K):  # K번의 교체
        # A의 원소가 최대가 되도록,
        # A의 원소가 B의 원소보다 작은 경우
        if A[i] < B[i]:
            # 두 원소를 교체
            A[i], B[i] = B[i], A[i]
        else:  # A의 원소가 B의 원소보다 크거나 같을 때 반복문 탈출
            break

    print(sum(A))
    ```