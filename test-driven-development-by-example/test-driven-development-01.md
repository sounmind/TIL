# Test-Driven Development: By Example

---

# 테스트 주도 개발이란,

---

# 1부 | 화폐예제

---

- 테스트 주도 개발의 리듬
    1. 재빨리 테스트를 하나 추가한다.
    2. 모든 테스트를 실행하고 새로 추가한 것이 실패하는지 확인한다.
    3. 코드를 조금 바꾼다.
    4. 모든 테스트를 실행하고 전부 성공하는지 확인한다.
    5. 리팩토링을 통해 중복을 제거한다.
- 작가가 독자에게 예측하는 놀랄만한 점
    1. 각각의 테스트가 기능의 작은 증가분을 어떻게 커버하는지
    2. 새 테스트를 돌아가게 하기 위해 얼마나 작고 못생긴 변화가 가능한지
    3. 얼마나 자주 테스트를 실행하는지
    4. 얼마나 수 없이 작은 단계를 통해 리팩토링이 되어가는지

# 1장 | 다중 통화를 지원하는 Money 객체

---

- 책 속 상황은 다음과 같다.

> 다중 통화가 적용되고 환율이 명시되는 새로운 보고서를 생성하려면 어떤 기능들이 있어야 할까?
즉, 어떤 테스트들이 있어야(이 테스트들이 모두 통과할 경우) 보고서에 제대로 계산되도록 하는 코드가 완성됐다는 걸 확신할 수 있을까?

- 책에서 제시된 테스트들은 다음과 같았다.
1. 통화가 다른 두 금액을 더해서 주어진 환율에 맞게 변한 금액을 결과로 얻을 수 있어야 한다.
2. 어떤 금액(주가)을 어떤 수(주식의 수)에 곱한 금액을 결과로 얻을 수 있어야 한다.

> 테스트를 작성할 때는 오퍼레이션의 환벽한 인터페이스에 대해 상상해보는 것이 좋다. 우리는 지금 오퍼레이션이 외부에서 어떤 식으로 보일지에 대한 이야기를 테스트 코드에 적고 있는 것이다.

오퍼레이션(operation)은 보통 메서드와 비슷한 의미로 쓰이며 객체가 수행할 수 있는 연산을 의미한다. 엄격하게는 오퍼레이션에 대한 특정한 하나의 구현을 메서드라고 부른다. 언어가 다형성을 지원할 경우 한 오퍼레이션은 여러 메서드를 가질 수 있다.

> 방금 우리가 작성한 테스트는 아직 컴파일 조차 되지 않는다. ... 실행은 안 되더라도 컴파일만은 되게 만들고 싶은데, 가장 쉬운 방법이 무엇일까? 현재 네 개의 컴파일 에러가 있다.

- 그리고 작가는 네 개의 컴파일 에러를 최소한의 구현으로 해결한다. 놀랍다. 이 과정만 들여다봐도 얼마나 구현 방식이 단계적인지 알 수 있다. 먼저 스케치를 한 다음 세밀한 부분을 채우는 것과 같다고 생각했다.

>